<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/markdown/identities.md at 2023-12-22
 | Rendered using Apache Maven Fluido Skin 1.12.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>Orne Beans &#x2013; Bean identities</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.12.0.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.12.0.min.js"></script>
  </head>
  <body>
    <a class="github-fork-ribbon right-top" href="https://github.com/orne-dev/java-beans" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>Orne Beans</h1>
</div>
</div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2023-12-22<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 0.6.0</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li><a href="index.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li class="active"><a><span class="none"></span>Identities</a></li>
    <li><a href="references.html" title="References"><span class="none"></span>References</a></li>
    <li><a href="converters.html" title="Converters"><span class="none"></span>Converters</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<h1>Bean identities</h1>
<p>Bean identities are properties of the beans that unmistakably identifies the
entity represented by the bean. It can be considered an abstraction of the
primary key in the ER paradigm.</p>
<p>Interface <code>Identity</code> provides an abstract mechanism to retrieve and manipulate
entity identities with zero knowledge of the composition of the identity.
Useful for referencing entities in front-ends and REST services without
exposing or depending of the implementation of the entities in the back-end
layer.</p>
<p>A default set of single value identity implementations is provided, including
implementations for identities of the next types:</p>
<ul>

<li><code>Long</code> (<code>LongIdentity</code>)</li>
<li><code>String</code> (<code>StringIdentity</code>)</li>
<li><code>BigInteger</code> (<code>BigIntegerIdentity</code>)</li>
</ul>
<p>The interface provides method <code>getIdentityToken()</code>, which returns a
<code>String</code> representation of the identity. This token must be used when exposed
through APIs, and should be a valid identifier in most of the contexts.</p><section>
<h2><a name="Token_identity"></a>Token identity</h2>
<p>When a identity is received through APIs the token should be converted to an
implementation of <code>TokenIdentity</code>, which represents an identity of unknown
type.</p>
<p>Only services directly responsible of identity composition (like DAOs) should
try to resolve the generic <code>TokenIdentity</code> to the required implementation.
Other components should use the passed identity &#x201c;as is&#x201d;.</p>
<p>To resolve <code>TokenIdentity</code> instances to specific identity implementations
the method <code>Identity.resolve(Class)</code> and the class <code>IdentityResolver</code>
is provided.
This class tries to create an instance of the requested identity type based on
the target class configuration (see <a href="#custom-identities">Custom identities</a>):</p>

<div class="source"><pre class="prettyprint"><code class="language-java">TokenIdentity unresolvedIdentity;
// Through Identity interface
MyIdentity resolvedIdentity = unresolvedIdentity.resolve(
        MyIdentity.class);
assertEquals(
        unresolvedIdentity.getIdentityToken(),
        resolvedIdentity.getIdentityToken());
// Through IdentityResolver utility class
IdentityResolver resolver = IdentityResolver.getInstance();
MyIdentity resolvedIdentity = resolver.resolve(
        unresolvedIdentity,
        MyIdentity.class);
assertEquals(
        unresolvedIdentity.getIdentityToken(),
        resolvedIdentity.getIdentityToken());

</code></pre></div></section><section>
<h2><a name="Custom_identities"></a>Custom identities</h2>
<p>To implement custom identities abstract classes <code>AbstractIdentity</code>,
<code>AbstractSimpleIdentity</code> and <code>AbstractComposedIdentity</code> are provided.
A custom identity must provide a identity body through method
<code>getIdentityTokenBody()</code> that represents the identity components as <code>String</code>
and a method to parse a identity token back to the identity type.
Class <code>AbstractSimpleIdentity</code> provides base methods to identities composed by
a single value.
Class <code>AbstractComposedIdentity</code> provides base methods to identities composed
by a multiple values.</p>
<p>To implement the token parsing method a constructor with a single <code>String</code>
argument is allowed. For implementations that cannot provide such a
constructor or prefer another method a public static method that accepts a
single <code>String</code> parameter annotated with <code>IdentityTokenResolver</code>
can be provided:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">class MyIdentity
extends AbstractSimpleIdentity&lt;CustomType&gt; {

    /**
     * Creates a new instance.
     * 
     * @param value The identity value
     */
    public MyIdentity(
            final CustomType value) {
        super(value);
    }

    /**
     * Copy constructor.
     * 
     * @param copy The instance to copy
     */
    public MyIdentity(
            final @NotNull MyIdentity copy) {
        super(copy);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected String getIdentityTokenBody() {
        // Implemented by AbstractSimpleIdentity. Can be overwritten
        // to customize String conversion.
        return this.getValue() == null ? null : this.getValue().toString();
    }

    /**
     * Resolves the specified identity token to a valid {@code MyIdentity}
     * 
     * @param token The identity token
     * @return The resolved identity token
     * @throws NullPointerException If the identity token is {@code null}
     * @throws UnrecognizedIdentityTokenException If the identity token is not
     * a valid identity token or it doesn't start with the expected prefix
     */
    @NotNull
    @IdentityTokenResolver
    public static MyIdentity fromIdentityToken(
            final @NotNull String token)
    throws UnrecognizedIdentityTokenException {
        final String body = IdentityTokenFormatter.parse(token);
        try {
            // Extract value from token body
            final CustomType value;
            if (body == null) {
                value = null;
            } else {
                value = CustomType.fromString(body);
            }
            return new MyIdentity(value);
        } catch (final SomeException se) {
            throw new UnrecognizedIdentityTokenException(
                &quot;Unrecognized identity token&quot;, se);
        }
    }
}
</code></pre></div>
<p>Identities composed by multiple values can choice any bidirectional method to
format and parse the identity token body. The resulting <code>String</code> will be
converted to Base64 to avoid illegal characters, so any suitable format is
allowed.
Abstract class <code>AbstractComposedIdentity</code> provides a default implementation
that concatenates and splits the components with a custom separator (uses <code>,</code>
by default):</p>

<div class="source"><pre class="prettyprint"><code class="language-java">class MyIdentity
extends AbstractComposedIdentity {

    /** First identity component. */
    private final CustomType value0;
    /** Second identity component. */
    private final CustomType2 value1;

    /**
     * Creates a new instance.
     * 
     * @param value0 The first identity component
     * @param value1 The second identity component
     */
    public MyIdentity(
            final CustomType value0,
            final CustomType2 value1) {
        super();
        this.value0 = value0;
        this.value1 = value1;
    }

    /**
     * Returns the first identity component.
     *
     * @return The first identity component
     */
    public CustomType getValue0() {
        return this.value0;
    }

    /**
     * Returns the second identity component.
     *
     * @return The second identity component
     */
    public CustomType2 getValue1() {
        return this.value1;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected @NotNull String[] getIdentityTokenBodyParts() {
        return new String[] {
            this.value0 == null ? null : this.value0.toString(),
            this.value1 == null ? null : this.value1.toString(),
        };
    }

    /**
     * Resolves the specified identity token to a valid {@code MyIdentity}
     * 
     * @param token The identity token
     * @return The resolved identity token
     * @throws NullPointerException If the identity token is {@code null}
     * @throws UnrecognizedIdentityTokenException If the identity token is not
     * a valid identity token or it doesn't start with the expected prefix
     */
    @NotNull
    @IdentityTokenResolver
    public static MyIdentity fromIdentityToken(
            final @NotNull String token)
    throws UnrecognizedIdentityTokenException {
        final String[] parts = AbstractComposedIdentity.extractRequiredTokenBodyParts(
                token,
                2);
        try {
            final CustomType value0;
            if (parts[0] == null) {
                value0 = null;
            } else {
                value0 = CustomType.fromString(parts[0]);
            }
            final CustomType2 value1;
            if (parts[1] == null) {
                value1 = null;
            } else {
                value1 = CustomType2.fromString(parts[1]);
            }
            return new MyIdentity(value0, value1);
        } catch (final SomeException se) {
            throw new UnrecognizedIdentityTokenException(
                &quot;Unrecognized identity token&quot;, se);
        }
    }
}
</code></pre></div>
<p>By default the default identity prefix provided by
<code>IdentityTokenFormatter.DEFAULT_PREFIX</code> (an empty string) is used.
If a custom identity prefers to generate token with a custom prefix method
<code>getIdentityTokenPrefix</code> can be overwritten, remembering to use same prefix
during token parsing:</p>

<div class="source"><pre class="prettyprint"><code class="language-java">class MyIdentity ... {

  public static final String CUSTOM_PREFIX = &quot;MYPREFIX&quot;;

  /**
   * {@inheritDoc}
   */
  @Nonnull
  @ValidIdentityTokenPrefix
  @Override
  protected String getIdentityTokenPrefix() {
      return CUSTOM_PREFIX
  }

  /**
   * Resolves the specified identity token to a valid {@code MyIdentity}
   * 
   * @param token The identity token
   * @return The resolved identity token
   * @throws NullPointerException If the identity token is {@code null}
   * @throws UnrecognizedIdentityTokenException If the identity token is not
   * a valid identity token or it doesn't start with the expected prefix
   */
  @NotNull
  @IdentityTokenResolver
  public static MyIdentity fromIdentityToken(
      @NotNull
      final String token)
  throws UnrecognizedIdentityTokenException {
    final String body = IdentityTokenFormatter.parse(
            CUSTOM_PREFIX,
            token);
    // ...
  }
}
</code></pre></div></section><section>
<h2><a name="Identity_beans"></a>Identity beans</h2>
<p>For implementing bean classes with identities the interface <code>IdentityBean</code> and
class <code>BaseIdentityBean</code> are provided:</p>

<div class="source"><pre class="prettyprint"><code>class MyBean extends BaseIdentityBean {

  /**
   * Empty constructor.
   */
  public MyBean() {
      super();
  }

  /**
   * Copy constructor.
   * 
   * @param copy The instance to copy
   */
  public MyBean(
          @Nonnull
          final MyBean copy) {
      super(copy);
      // Copy properties
  }
}

MyBean bean = new MyBean();
bean.setIdentity(beanIdentity);
assertEquals(
        beanIdentity.getIdentityToken(),
        bean.getIdentity().getIdentityToken());
</code></pre></div></section><section>
<h2><a name="Identity_beans_validation"></a>Identity beans validation</h2>
<p>For validating that a passed bean contains a valid identity annotation
<code>ValidBeanIdentity</code> is provided. This annotation validates that a valid
identity is provided. If the identity is an instance of <code>TokenIdentity</code> this
validation does not check that the token is in the expected format.</p>

<div class="source"><pre class="prettyprint"><code class="language-java">void myMethod(
    @ValidBeanIdentity
    MyBean bean) {
  // ...
}
</code></pre></div>
<p>Utility class <code>BeanValidationUtils</code> provides method <code>isValidBeanIdentity()</code>
to check programmatically if a <code>IdentityBean</code> has a valid identity. Under the
hoods validates the bean against the <code>IdentityBean.RequireIdentity</code> group.</p></section><section>
<h2><a name="Identity_serialization_and_conversion"></a>Identity serialization and conversion</h2>
<p>The library provides &#x201c;out of the box&#x201d; configuration for Java Serialization,
Jackson based JSON serialization, JAXB based XML serialization and Java Beans
editor based conversion.</p></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>©      2020–2023
<a href="https://github.com/orne-dev">Orne Developments</a>
</p>
        </div>
      </div>
    </footer>
<script>
  if(anchors) {
    anchors.add();
  }
</script>
  </body>
</html>